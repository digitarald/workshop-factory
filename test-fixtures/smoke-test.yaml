title: Intro to TypeScript
topic: typescript-basics
audience:
  level: beginner
  stack: TypeScript/Node.js
duration: 60
prerequisites:
  - Basic JavaScript knowledge
context_sources: []
modules:
  - title: Getting Started with TypeScript
    duration: 30
    learning_objectives:
      - text: Set up a TypeScript project
        blooms_level: apply
      - text: Understand type annotations
        blooms_level: understand
    sections:
      - type: lecture
        title: What is TypeScript?
        duration: 5
        talking_points:
          - >-
            TypeScript is a superset of JavaScript — every valid JS file is
            already valid TS
          - >-
            The type system acts as a safety net, catching bugs before your code
            ever runs
          - >-
            TypeScript compiles (transpiles) down to standard JavaScript that
            runs anywhere JS does
          - >-
            Major frameworks like Angular, Next.js, and Deno use TypeScript by
            default
      - type: exercise
        title: Your First TypeScript File
        duration: 15
        instructions: >-
          Initialize a new TypeScript project with `npm init -y && npm install
          typescript --save-dev && npx tsc --init`. Then create a file called
          `greeter.ts` that declares variables with explicit type annotations
          for a person's name, age, and a list of hobbies. Finally, write a
          function `introduce` that accepts those values and returns a formatted
          greeting string. Compile with `npx tsc` and run the output with `node
          greeter.js`.
        starter_code: |
          // greeter.ts
          // TODO: Annotate each variable with its type
          let name = "Alice"
          let age = 30
          let hobbies = ["reading", "hiking"]

          // TODO: Add parameter types and a return type
          function introduce(name, age, hobbies) {
            return `Hi, I'm ${name}, ${age} years old. I enjoy ${hobbies.join(", ")}.`
          }

          console.log(introduce(name, age, hobbies))
        solution: >
          // greeter.ts

          let name: string = "Alice"

          let age: number = 30

          let hobbies: string[] = ["reading", "hiking"]


          function introduce(name: string, age: number, hobbies: string[]):
          string {
            return `Hi, I'm ${name}, ${age} years old. I enjoy ${hobbies.join(", ")}.`
          }


          console.log(introduce(name, age, hobbies))
        hints:
          - 'Primitive types use lowercase keywords: string, number, boolean'
          - Arrays can be typed as string[] or Array<string>
          - >-
            A function's return type is placed after the parameter list:
            function foo(): string { ... }
      - type: checkpoint
        title: Type Basics Check
        duration: 5
        questions:
          - What file does `npx tsc --init` create, and what is its purpose?
          - >-
            If you declare `let score: number = 100` and later write `score =
            "high"`, what happens?
        expected_answers:
          - >-
            It creates tsconfig.json, which configures the TypeScript compiler
            options for the project.
          - >-
            The TypeScript compiler raises a type error because a string cannot
            be assigned to a variable typed as number.
        explanations:
          - >-
            tsconfig.json controls settings like target JS version, module
            system, strict mode, and which files to compile.
          - >-
            Static type checking enforces that values match their declared types
            at compile time, preventing entire categories of runtime bugs.
      - type: discussion
        title: When to Use TypeScript
        duration: 5
        prompts:
          - >-
            Think of a bug you've encountered in JavaScript that would have been
            caught by a type checker. What was the root cause?
          - >-
            In what scenarios might starting with plain JavaScript and migrating
            later make more sense than using TypeScript from day one?
  - title: Functions and Interfaces
    duration: 30
    learning_objectives:
      - text: Define typed functions
        blooms_level: apply
      - text: Create and use interfaces
        blooms_level: apply
    sections:
      - type: lecture
        title: Typing Functions
        duration: 5
        talking_points:
          - >-
            Every function parameter should have a type annotation; TypeScript
            does not infer parameter types from usage
          - >-
            Return types can be inferred but adding them explicitly serves as
            documentation and catches accidental changes
          - >-
            Optional parameters use the `?` suffix and must come after required
            parameters: `function greet(name: string, title?: string)`
          - >-
            Default parameter values let TypeScript infer the type
            automatically: `function delay(ms = 1000)` infers `number`
          - >-
            Interfaces can describe function shapes using call signatures:
            `interface Formatter { (input: string): string }`
      - type: exercise
        title: Build a Typed Utility
        duration: 15
        instructions: >-
          Create a module called `mathUtils.ts` that exports three typed
          functions: (1) `clamp(value, min, max)` — returns the value
          constrained between min and max, (2) `average(...nums)` — accepts a
          rest parameter of numbers and returns their average, and (3) define an
          interface `Range` with properties `min: number` and `max: number`,
          then write `isInRange(value, range)` that returns whether the value
          falls within the given Range. Export all functions and the interface.
        starter_code: |
          // mathUtils.ts

          // TODO: Define a Range interface

          // TODO: Add types to all parameters and return values
          function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max)
          }

          function average(...nums) {
            const sum = nums.reduce((a, b) => a + b, 0)
            return sum / nums.length
          }

          function isInRange(value, range) {
            return value >= range.min && value <= range.max
          }

          export { clamp, average, isInRange }
        solution: >
          // mathUtils.ts


          export interface Range {
            min: number
            max: number
          }


          export function clamp(value: number, min: number, max: number): number
          {
            return Math.min(Math.max(value, min), max)
          }


          export function average(...nums: number[]): number {
            const sum = nums.reduce((a, b) => a + b, 0)
            return sum / nums.length
          }


          export function isInRange(value: number, range: Range): boolean {
            return value >= range.min && value <= range.max
          }
        hints:
          - 'Rest parameters are typed as arrays: `...items: number[]`'
          - >-
            An interface groups related properties: `interface Range { min:
            number; max: number }`
          - >-
            Use the interface name as a parameter type just like a primitive:
            `range: Range`
      - type: checkpoint
        title: Functions & Interfaces Check
        duration: 5
        questions:
          - >-
            What is the difference between an optional parameter (`name?:
            string`) and a parameter with a default value (`name = "World"`)?
          - Can an interface extend another interface? Give a one-line example.
        expected_answers:
          - >-
            An optional parameter may be undefined and has no fallback, while a
            default-value parameter automatically uses the specified value when
            omitted.
          - >-
            Yes. Example: `interface Square extends Shape { sideLength: number
            }`
        explanations:
          - >-
            Optional parameters require you to handle `undefined` in the
            function body, whereas defaults guarantee a usable value — choose
            based on whether a sensible fallback exists.
          - >-
            Interface extension is one of TypeScript's key composition tools;
            the child interface inherits all parent properties and can add new
            ones, enabling incremental type modeling.
      - type: discussion
        title: Wrap Up
        duration: 5
        prompts:
          - >-
            How would you decide whether to use an interface or a type alias
            when modeling data in a new project?
          - >-
            What is one thing you plan to refactor or build differently now that
            you know how to type functions and interfaces?
